<!DOCTYPE html>
<html lang="en" class="h-full">
<head>
  <meta charset="utf-8" />
  <title>Media Prospect Manager</title>
  <base target="_top">
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="description" content="Manage and track media outreach prospects with a real-time Supabase database.">

  <script defer src="https://cdn.tailwindcss.com"></script> 
  
  <script src="https://cdn.jsdelivr.net/npm/@supabase-js@2.43.4/dist/umd/supabase.min.js"></script> 
  
  <script>
    // --- Supabase Client Setup (Now guaranteed 'supabase' exists) ---
    const { createClient } = supabase; 
    const supabaseClient = createClient(
      'https://mfjymrrykhvfkivtvgit.supabase.co', // <<< YOUR URL
      'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Im1manltcnJ5a2h2ZmtpdnR2Z2l0Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjEwNzY1MzksImV4cCI6MjA3NjY1MjUzOX0.wgn7fZgL8vmedKWmJ8BNfwbaOzZ4ZFltqcDrkEDvsnw' // <<< YOUR KEY
    );

    // --- Define Alpine Data Directly (No alpine:init needed now) ---
    function prospectApp() {
        // ... ALL your original component code ({ db: [], init(), load(), etc. }) ...
        // Make sure all methods use 'supabaseClient' defined above
       return {
            db: [],
            pasteInput: '',
            ingestSummary: { total: 0, newCount: 0, dupeCount: 0, invalidCount: 0 },
            search: '',
            filterStatus: '',
            hideRejected: false,
            showAddForm: false,
            addFormCampaign: '',
            campaigns: [],
            selectedCampaign: 'all',
            newCampaignName: '',
            showNewCampaignInput: false,
            statuses: [
              { value: 'unvetted', label: 'Unvetted' },
              { value: 'good', label: 'Good Fit' },
              { value: 'rejected', label: 'Rejected' },
              { value: 'contacted', label: 'Contacted' },
              { value: 'done', label: 'Done' }
            ],
    
            async init() {
              console.log("prospectApp init() called"); 
              await this.load();
              this.deriveCampaigns();
    
              console.log("Subscribing to 'test-channel'...");
              supabaseClient.channel('test-channel').subscribe((status) => { // Added status log
                console.log("TEST CHANNEL STATUS:", status); 
              }); 
    
              this.initSubscription();
            },
    
             initSubscription() {
                supabaseClient.removeAllChannels();
                console.log("Attempting to subscribe to real-time updates...");
                supabaseClient.channel('public:mediadb')
                .on(
                  'postgres_changes',
                  { event: '*', schema: 'public', table: 'mediadb' },
                  (payload) => {
                    try { // Added try-catch
                      console.log('Real-time change received!', payload);
                      this.handleRealtimeChange(payload);
                    } catch (error) {
                      console.error("Error processing real-time event:", error, payload);
                    }
                  }
                )
                .subscribe((status, err) => { // Added error logging
                  if (status === 'SUBSCRIBED') {
                    console.log('✅ Successfully subscribed to real-time updates!'); // Use checkmark
                  } else if (status === 'CHANNEL_ERROR' || status === 'TIMED_OUT') {
                    console.error(`❌ Realtime connection ${status}:`, err || 'No error details'); // Use X mark
                    console.log('Attempting to re-subscribe in 5 seconds...');
                    setTimeout(() => this.initSubscription(), 5000);
                  } else {
                    console.warn('Realtime subscription status:', status); // Use warn for other statuses
                  }
                });
            },
            
            handleRealtimeChange(payload) {
                try {
                    let campaignListChanged = false;
    
                    if (payload.eventType === 'INSERT') {
                      if (!this.db.some(item => item.id === payload.new.id)) {
                        this.db = [payload.new, ...this.db];
                        if (payload.new.campaign && !this.campaigns.includes(payload.new.campaign)) {
                          campaignListChanged = true;
                        }
                      } else {
                          console.warn("Realtime: Received INSERT for existing ID, skipping:", payload.new.id);
                      }
                    }
                    else if (payload.eventType === 'UPDATE') {
                      const index = this.db.findIndex(r => r.id === payload.new.id);
                      if (index !== -1) {
                          this.db = [
                              ...this.db.slice(0, index),
                              payload.new,
                              ...this.db.slice(index + 1)
                          ];
                        if (payload.new.campaign && !this.campaigns.includes(payload.new.campaign)) {
                          campaignListChanged = true;
                        }
                      } else {
                          console.warn("Realtime: Received UPDATE for non-existent ID, maybe add it?", payload.new.id);
                          // Optionally add if missing:
                          // if (!this.db.some(item => item.id === payload.new.id)) {
                          //     this.db = [payload.new, ...this.db]; 
                          // }
                      }
                    }
                    else if (payload.eventType === 'DELETE') {
                      const initialLength = this.db.length;
                      this.db = this.db.filter(r => r.id !== payload.old.id);
                      // Only re-derive if something was actually deleted
                      if(this.db.length < initialLength){ 
                          campaignListChanged = true;
                      }
                    }
                    if (campaignListChanged) {
                      this.deriveCampaigns();
                    }
                } catch (error) {
                      console.error("Error inside handleRealtimeChange logic:", error, payload);
                }
            },
            
            deriveCampaigns() {
                const allCampaigns = this.db
                    .map(r => r.campaign)
                    .filter(Boolean); // Filter out null/empty strings
                this.campaigns = [...new Set(allCampaigns)].sort();
            },
            
            async load() {
                console.log("Loading initial data...");
                const { data, error } = await supabaseClient
                    .from('mediadb')
                    .select('*')
                    .order('created_at', { ascending: false });
    
                if (error) {
                    console.error('Error loading data:', error.message); // Log only message
                    alert('Error loading data. Check console.'); // Simpler alert
                } else {
                    console.log(`Data loaded successfully (${data?.length || 0} rows).`); // Log row count
                    this.db = data || []; // Ensure db is always an array
                }
            },
            
            async ingest() {
                const campaignToAssign = this.addFormCampaign === 'unassigned' ? '' : this.addFormCampaign;
                  if (this.addFormCampaign === '') {
                    alert('Please select a campaign to assign these prospects to.');
                    return;
                  }
                  // More robust line splitting and filtering
                  const lines = (this.pasteInput || '').split(/[\r\n]+/).map(l => l.trim()).filter(Boolean);
                  if (lines.length === 0) {
                      alert('Paste input is empty.');
                      return;
                  }

                  console.log(`Attempting to ingest ${lines.length} lines for campaign: ${campaignToAssign || 'Unassigned'}`);
                  let newRows = [];
                  // Use lowercase for comparisons
                  let currentDomains = new Set(this.db.map(r => r.domain?.toLowerCase())); 

                  for (const line of lines) {
                    // Extract domain more carefully
                    const domain = this.normalizeDomain(line.split(/[,;\s\t]/)[0]); 
                    if (!domain) {
                        console.warn(`Skipping invalid input line: "${line}"`);
                        continue;
                    };
                    const lowerDomain = domain.toLowerCase();
                    // Check against lowercase set
                    if (currentDomains.has(lowerDomain)) {
                         console.log(`Skipping duplicate domain (already exists): ${domain}`);
                         continue; 
                    }
                    // Check against domains added *in this batch* (case-insensitive)
                    if (newRows.some(r => r.domain.toLowerCase() === lowerDomain)) {
                         console.log(`Skipping duplicate domain (in this batch): ${domain}`);
                         continue;
                    }

                    newRows.push({
                      domain: domain, // Store original casing if needed, though normalize lowercases
                      campaign: campaignToAssign,
                      status: 'unvetted'
                    });
                  }

                  const invalidCount = lines.length - currentDomains.size - newRows.length; // Approximate invalid/dupe count
                  const dupeCount = lines.length - newRows.length - invalidCount;


                  if (newRows.length > 0) {
                      console.log(`Inserting ${newRows.length} unique new rows...`);
                    // Add .select() to get inserted data back for immediate UI update (optional but good practice)
                    const { data: insertedData, error } = await supabaseClient
                        .from('mediadb')
                        .insert(newRows)
                        .select(); 

                    if (error) {
                      console.error('Error creating prospects:', error.message);
                      alert('Error creating prospects. Check console.');
                    } else {
                      console.log("Prospects inserted successfully.");
                      // Optionally merge insertedData with this.db if not relying purely on realtime
                      // this.db = [...insertedData, ...this.db]; // Simple merge, might need sorting
                      this.pasteInput = '';
                      this.ingestSummary = { total: lines.length, newCount: newRows.length, dupeCount, invalidCount };
                      this.showAddForm = false;
                      // Manually re-derive campaigns if not relying purely on realtime
                      // this.deriveCampaigns(); 
                    }
                  } else {
                      console.log("No unique new rows to insert.");
                      this.ingestSummary = { total: lines.length, newCount: 0, dupeCount, invalidCount };
                      // Maybe keep form open if nothing was added?
                      // alert(`Processed ${lines.length} lines. No new unique domains found to add.`);
                  }
            },
    
            async updateProspect(p) {
                // Debounce or prevent rapid updates if needed
                console.log(`Attempting to update prospect ID: ${p.id}`);
                  const { error } = await supabaseClient
                    .from('mediadb')
                    .update({
                      status: p.status,
                      contact: p.contact,
                      notes: p.notes,
                      campaign: p.campaign
                    })
                    .eq('id', p.id);
    
                  if (error) {
                      console.error('Error updating prospect:', error.message);
                      alert('Error updating prospect. Check console.');
                  } else {
                      console.log("Prospect update successful via API call.");
                      // Manually update campaign list if changed
                      if(p.campaign && !this.campaigns.includes(p.campaign)) {
                          this.deriveCampaigns();
                      }
                  }
            },
    
            async deleteProspect(id) {
                if (!confirm(`Are you sure you want to delete prospect ID: ${id}?`)) return; // Show ID
                  console.log(`Attempting to delete prospect ID: ${id}`);
                  const { error } = await supabaseClient
                    .from('mediadb')
                    .delete()
                    .eq('id', id);
    
                  if (error) {
                      console.error('Error deleting prospect:', error.message);
                      alert('Error deleting prospect. Check console.');
                  } else {
                      console.log("Prospect deleted successfully via API call.");
                      // Realtime should remove it, but you could filter locally too:
                      // this.db = this.db.filter(r => r.id !== id);
                      // this.deriveCampaigns();
                  }
            },
    
            // --- HELPER FUNCTIONS ---
             normalizeDomain(input) {
                let s = (input || '').trim().toLowerCase();
                  // Remove protocol more robustly
                  s = s.replace(/^(?:https?:\/\/|ftp:\/\/)?(?:www\.)?/i, ''); 
                  // Remove email part if present
                  s = s.replace(/^[^@]+@/, ''); 
                  // Remove path, query, fragment, port
                  s = s.split(/[:/?#]/)[0]; 
                  // Remove trailing dot
                  s = s.replace(/\.$/, ''); 
                  // Basic validation (adjust regex if needed for international domains)
                  if (!/^[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?)+$/i.test(s)) return null;
                  return s;
            },
            addNewCampaign() {
                const name = this.newCampaignName.trim();
                    if (!name) { alert('Please enter a valid campaign name.'); return; }
                    // Case-insensitive check
                    if (this.campaigns.some(c => c.toLowerCase() === name.toLowerCase())) { 
                        alert(`Campaign "${name}" already exists.`); 
                        return; 
                    }
                    this.campaigns.push(name); 
                    this.campaigns.sort((a, b) => a.localeCompare(b)); // Better sorting
                    this.addFormCampaign = name; // Select the new campaign
                    this.newCampaignName = '';
                    this.showNewCampaignInput = false;
            },
            get filtered() {
                let rows = this.db; 
                  // Handle 'Unassigned' filter explicitly
                  if (this.selectedCampaign === '') { // Check for empty string for Unassigned
                     rows = rows.filter(r => !r.campaign); 
                  } else if (this.selectedCampaign !== 'all') { 
                     rows = rows.filter(r => r.campaign === this.selectedCampaign); 
                  }
                  
                  if (this.filterStatus) rows = rows.filter(r => r.status === this.filterStatus); 
                  if (this.hideRejected) rows = rows.filter(r => r.status !== 'rejected'); 
                  
                  const q = this.search.trim().toLowerCase();
                  if (q) { 
                      rows = rows.filter(r =>
                        (r.domain?.toLowerCase() || '').includes(q) || // Add null checks
                        (r.contact?.toLowerCase() || '').includes(q) ||
                        (r.notes?.toLowerCase() || '').includes(q) ||
                        (r.campaign?.toLowerCase() || '').includes(q)
                      );
                  }
                  // Return a new sorted array to ensure reactivity if needed elsewhere
                  return [...rows].sort((a,b) => new Date(b.created_at) - new Date(a.created_at));
            },
            countByStatus(status) {
                let relevantData = this.db;
                  // Handle 'Unassigned' count
                  if (this.selectedCampaign === '') {
                     relevantData = this.db.filter(r => !r.campaign);
                  } else if (this.selectedCampaign !== 'all') { 
                     relevantData = this.db.filter(r => r.campaign === this.selectedCampaign); 
                  }
                  return relevantData.filter(r => r.status === status).length;
            },
            formatDate(iso) {
                if (!iso) return 'N/A'; // Handle null dates better
                try { // Add try-catch for invalid date strings
                    const d = new Date(iso);
                    // Use Intl for better formatting (optional)
                    // return new Intl.DateTimeFormat(undefined, { dateStyle: 'short', timeStyle: 'short' }).format(d);
                    return d.toLocaleDateString() + ' ' + d.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
                } catch (e) {
                    console.error("Error formatting date:", iso, e);
                    return 'Invalid Date';
                }
            },
            exportCSV(all) {
                let rowsToExport;
                let campaignName = 'all_campaigns';
                if (this.selectedCampaign === '') { campaignName = 'unassigned'; }
                else if (this.selectedCampaign !== 'all') { campaignName = this.selectedCampaign.replace(/[^a-z0-9]/gi, '_').toLowerCase(); }

                if (all) {
                    rowsToExport = this.selectedCampaign !== 'all'
                        ? this.db.filter(r => this.selectedCampaign === '' ? !r.campaign : r.campaign === this.selectedCampaign)
                        : this.db.slice(); 
                    rowsToExport.sort((a, b) => new Date(b.created_at) - new Date(a.created_at));
                } else { 
                    rowsToExport = this.filtered; // Already sorted and filtered
                    // Update campaign name if exporting filtered results
                    if(this.selectedCampaign !== 'all') campaignName = `filtered_${campaignName}`;
                } 

                if (rowsToExport.length === 0) {
                    alert("No data available to export for the current selection.");
                    return;
                }

                const headers = ['id', 'domain', 'status', 'contact', 'notes', 'created_at', 'campaign'];
                const escape = v => `"${String(v === null || v === undefined ? '' : v).replace(/"/g, '""')}"`; // Handle null/undefined
                try { // Add try-catch for CSV generation
                    const csv = [headers.join(',')].concat(rowsToExport.map(r => headers.map(h => escape(r[h])).join(','))).join('\n');
                    const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' }); 
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `prospects_${campaignName}_${new Date().toISOString().replace(/[:.]/g, '-')}.csv`;
                    document.body.appendChild(a); // Append for Firefox compatibility
                    a.click();
                    document.body.removeChild(a); // Clean up
                    URL.revokeObjectURL(url);
                } catch (e) {
                    console.error("Error generating or downloading CSV:", e);
                    alert("Failed to generate CSV. Check console for details.");
                }
            }
        }; // End of return {}
    } // End of prospectApp()
  </script>

  <style>
    td, th { white-space: nowrap; }
    td textarea { min-height: 2.25rem; }
  </style>
</head>

<body class="h-full bg-gray-50 text-gray-900">
  <div class="max-w-7xl mx-auto p-4" x-data="prospectApp()" x-init="init()">
    
    <div class="flex items-start sm:items-center justify-between gap-4 flex-col sm:flex-row">
       <div>
         <h1 class="text-2xl font-semibold">Media Prospect Manager</h1>
         <p class="text-sm text-gray-600">Now powered by Supabase — fast, real-time, and jank-free.</p>
       </div>
       <div class="flex gap-2">
         <button @click="exportCSV(false)" class="px-3 py-2 text-sm rounded-md border bg-white hover:bg-gray-50">Export Filtered CSV</button>
         <button @click="exportCSV(true)" class="px-3 py-2 text-sm rounded-md border bg-white hover:bg-gray-50">Export All CSV</button>
       </div>
     </div>

     <div class="grid grid-cols-2 md:grid-cols-6 gap-3 mt-4">
         <template x-for="s in statuses" :key="s.value">
           <div class="rounded-lg border bg-white p-3">
             <div class="text-xs text-gray-500" x-text="s.label"></div>
             <div class="text-xl font-semibold" x-text="countByStatus(s.value)"></div>
           </div>
         </template>
       </div>
    
       <div class="mt-6 text-right">
           <button @click="showAddForm = true" x-show="!showAddForm" class="px-4 py-2 rounded-md text-white bg-gray-900 hover:bg-gray-800">
             Add New Prospects
           </button>
         </div>

        <div class="mt-6 rounded-lg border bg-white p-4" x-show="showAddForm" x-transition>
            </div>

       <div class="mt-6 grid grid-cols-1 md:grid-cols-4 gap-3">
            </div>

      <div class="mt-4 overflow-auto rounded-lg border bg-white">
          <table class="min-w-full text-sm">
             </table>
      </div>

  </div>

  <script defer src="https://unpkg.com/alpinejs@3.x.x/dist/cdn.min.js"></script> 
</body>
</html>
